"""
Greg McInes
Altman Lab
gmcinnes@stanford.edu
"""


'''
This script will generate a VCF for a genetic case-control study

Two inputs our required:
- A disease manifest which lists all genetic mechanisms of disease
- A file with all possible variants and their allele frequencies (ExAC format)

Cases will be generated according to disease models specified in the manifest
Controls will be generated by randomly generated variants according to the oberserved allele frequencies in the provided
file.  For now, no LD is considered.  Some controls genetic patterns may be specified in the manifest, in cases where 
there is a known protective mechanism.  Controls will be explicitly checked to not have any disease patterns specified 
in the manifest.

'''

import argparse
#import json
import numpy as np
#from collections import namedtuple
#import sys

from lib import Manifest, Variant, Region, Pattern, Sample, SampleStore

class GSim(object):
    def __init__(self, manifest, freq_file, count=100, prefix=None, debug=False):
        self.debug = debug
        # Read in the manifest and store it as a dictionary
        self.manifest = Manifest(manifest)
        # Generate a set of variants specified in the manifest to be associated with disease somehow.
        # Specify the frequency file
        self.freq_file = freq_file

        self.count = int(count)

        self.samples = None

        self.prefix = prefix
        if prefix is None:
            self.prefix = "gsim.%s" % count
        self.run()

    def run(self):
        # Read in the manifest
        print("Running!")
        # need to set the number of cases and controls
        # Read in the manifest and read in all the defined variants, these should be stored in a list and checked against
        # for every varinat read in from the frequency file
        # Need to print out a final list of the sampels and which group they belong to
        # Option to randomly sample from the proportions defined in the manifest or have exact counts based on proportions
        # Option to print either VCF or plink

        # Set the ids of the cases and controls
        self.generate_samples()

        # Generate variants
        self.generate_variants()



    def generate_variants(self):
        # First generate variants specified in the manifest
        self.generate_pattern_variants()

        # Then generate the rest of the variants
        self.generate_nonpattern_variants()



    def generate_pattern_variants(self):
        print("Generating manifest variants")
        for s in self.samples.samples:
            sample = self.samples.samples[s]
            # If a sample has been assigned to the 'random' pattern, skip it.
            if sample.pattern == "random":
                continue
            # Get the pattern data from the manifest
            pattern_data = self.manifest.patterns[sample.pattern]
            #pattern_data.print_summary()
            sample.add_genotype(pattern_data.generate_variants(phenotype=sample.phenotype))
            #sample.print_sample()



    def generate_nonpattern_variants(self):
        print("Generating remaining variants")
        # Later on when I have more than one region i'll want to index the file and read in only the segments i'm processing
        # But for now, just read everything in.
        # Need to check the next line after each variant to see if it's multiallelic

        vcf_output = self.prefix + ".vcf"
        vcf_f = open(vcf_output, 'w')
        self.print_header(vcf_f)
        with open(self.freq_file) as f:
            chrom = 0
            position = 1
            ref = 3
            alt = 4
            af = 14
            previous = 0
            f.readline()
            line = f.readline()

            while line:
                fields = line.rstrip().replace('"','').split(",")

                current_chromosome = fields[chrom]
                current_position = fields[position]
                current_ref = fields[ref]
                current_alt = fields[alt]
                alts = [current_alt]
                current_af = float(fields[af])
                key = self.variant_key(current_chromosome, current_position, current_ref, current_alt)

                # Check if this variant was already processed
                if "%s-%s" % (current_position, current_ref) == previous:
                    line = f.readline()
                    continue
                # Check if the position is in the variants file
                manifest_variant = key in self.manifest.variants

                # Create lists to sample genotypes from
                genotypes = []
                probabilities = []

                # Add first alternate allele and allele frequency
                genotypes.append('1')
                probabilities.append(current_af)

                # Peek at the next variant to see if it is multiallelic
                # If it is add the allele to the genotype and the frequency to probabilities
                is_multiallelic = self.check_multiallelic(f, current_position, current_ref)
                if is_multiallelic:
                    next_line = self.peek_line(f)
                    next_fields = next_line.rstrip().replace('"','').split(",")
                    next_alt = next_fields[alt]
                    alts.append(next_alt)
                    next_af = float(next_fields[af])
                    genotypes.append('2')
                    probabilities.append(next_af)

                # Add the reference allele with the remaining allele frequency
                genotypes.append('0')
                probabilities.append(1 - sum(i for i in probabilities) )

                # Generate variants for each sample
                position_variants = []
                for s in self.samples.samples:
                    # check if the variant is defined for the samples
                    if manifest_variant and key in self.samples.samples[s].genotype:
                        genotype = self.samples.samples[s].genotype[key]
                    else:
                        genotype = self.random_genotype(genotypes, probabilities)
                    position_variants.append("/".join(genotype))
                #print(all)
                vcf_f.write("%s\t%s\t%s\t%s\t30\tPASS\t.\tGT\t%s\n" %
                      (current_chromosome, current_position, current_ref, ",".join(alts), "\t".join(position_variants)))
                previous = "%s-%s" % (current_position, current_ref)
                line = f.readline()

    def print_header(self, file=None):
        stock_header = "##fileformat=VCFv4.2\n\
##fileDate=20090805\n\
##source=myImputationProgramV3.1\n\
##reference=file:///seq/references/1000GenomesPilot-NCBI36.fasta\n\
##contig=<ID=20,length=62435964,assembly=B36,md5=f126cdf8a6e0c7f379d618ff66beb2da,species=\"Homo sapiens\",taxonomy=x>\n\
##phasing=partial\n\
##INFO=<ID=NS,Number=1,Type=Integer,Description=\"Number of Samples With Data\">\n\
##INFO=<ID=DP,Number=1,Type=Integer,Description=\"Total Depth\">\n\
##INFO=<ID=AF,Number=A,Type=Float,Description=\"Allele Frequency\">\n\
##INFO=<ID=AA,Number=1,Type=String,Description=\"Ancestral Allele\">\n\
##INFO=<ID=DB,Number=0,Type=Flag,Description=\"dbSNP membership, build 129\">\n\
##INFO=<ID=H2,Number=0,Type=Flag,Description=\"HapMap2 membership\">\n\
##FILTER=<ID=q10,Description=\"Quality below 10\">\n\
##FILTER=<ID=s50,Description=\"Less than 50% of samples have data\">\n\
##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype\">\n\
##FORMAT=<ID=GQ,Number=1,Type=Integer,Description=\"Genotype Quality\">\n\
##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\"Read Depth\">\n\
##FORMAT=<ID=HQ,Number=2,Type=Integer,Description=\"Haplotype Quality\">\n"
        column_headings = "#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\t" + \
                          "\t".join(self.samples.samples.keys()) + "\n"

        if file is None:
            print(stock_header)
            print(column_headings)
        else:
            file.write(stock_header)
            file.write(column_headings)


    def print_phe_file(self):
        print("phe file")
        phenotype_file = self.prefix + ".assignments.csv"
        f = open(phenotype_file, 'w')
        for s in self.samples.samples:
            sample = self.samples.samples[s]
            f.write("%s,%s,%s\n" % (sample.id, sample.phenotype, sample.pattern))
        f.close()

    def random_genotype(self, genotypes, probabilities):
        return np.random.choice(genotypes, 2, p=probabilities).tolist()

    def check_multiallelic(self, f, current, ref):
        peek = self.peek_line(f)
        try:
            if peek is not None:
                fields = peek.rstrip().replace('"', '').split(",")
                if fields[1] == current and fields[3] == ref:
                    return True
            return False
        except:
            return False

    def variant_key(self, chrom, pos, ref, alt):
        return "%s-%s-%s-%s" % (chrom, pos, ref, alt)

    def peek_line(self, f, count=1):
        try:
            pos = f.tell()
            line = None
            for i in range(count):
                line = f.readline()
            f.seek(pos)
            return line
        except:
            return None

    def generate_samples(self):
        cases, controls = self.generate_sample_ids()
        count = 0
        samples = SampleStore()
        for c in cases:
            id = "LG" + str(count).zfill(6)
            new_case = Sample(id = id, phenotype="case", pattern=c)
            #new_case.print_sample()
            samples.add_sample(new_case)
            count += 1
        for c in controls:
            id = "LG" + str(count).zfill(6)
            new_control = Sample(id = id, phenotype="control", pattern=c)
            #new_control.print_sample()
            samples.add_sample(new_control)
            count += 1

        samples.print_summary()
        self.samples = samples
        self.print_phe_file()

    def generate_sample_ids(self):
        case_patterns = {}
        control_patterns = {}
        
        case_total = 0
        control_total = 0

        for p in self.manifest.patterns.keys():
            case = self.manifest.patterns[p].case_proportion
            control = self.manifest.patterns[p].control_proportion
            
            case_total += case
            control_total += control
            
            if case > 0:
                case_patterns[p] = case
            if control > 0:
                control_patterns[p] = control

        if case_total > 1:
            print("Case proportion values invalid")
        if control_total > 1:
            print("Control proportion values invalid")

        if case_total < 1:
            case_patterns['random'] = 1 - case_total

        if control_total < 1:
            control_patterns['random'] = 1 - control_total

        cases = self.random_sample(int(self.count / 2), case_patterns)
        controls = self.random_sample(int(self.count / 2), control_patterns)

        return cases, controls

    def random_sample(self, count, patterns):
        ids = list(patterns.keys())
        values = []
        for k in ids:
            values.append(patterns[k])
        return np.random.choice(ids, count, p=values).tolist()



"""
Parse the command line
"""
def parse_command_line():
    parser = argparse.ArgumentParser(
        description = 'Generate simulated data based on preset disease patterns')
    parser.add_argument("-m", "--manifest", help="Manifest")
    parser.add_argument("-f", "--freq_file", help="ExAC frequency file")
    parser.add_argument("-n", "--count", help="Number of samples to generate")
    parser.add_argument("-p", "--prefix", default=None, help="Output file prefix")
    parser.add_argument("-d", "--debug", action='store_true', default=False,
                                help="Output debugging messages.  May be very verbose.")
    options = parser.parse_args()

    if not options.manifest or not options.freq_file:
        print("Insufficient options")
        parser.print_help()
        exit()

    return options


"""
Main
"""
if __name__ == "__main__":
    options = parse_command_line()
    GSim(options.manifest, options.freq_file, options.count, options.prefix, options.debug)

